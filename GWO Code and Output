import numpy as np


def gwo(obj_func, dim, search_space, n_agents=20, max_iter=100):
    lb, ub = search_space
    wolves = np.random.uniform(lb, ub, (n_agents, dim))
    alpha, beta, delta = None, None, None
    alpha_score, beta_score, delta_score = float("inf"), float("inf"), float("inf")

    for t in range(max_iter):
        # Evaluate fitness of each wolf
        for i in range(n_agents):
            fitness = obj_func(wolves[i])
            if fitness < alpha_score:
                delta_score, delta = beta_score, beta
                beta_score, beta = alpha_score, alpha
                alpha_score, alpha = fitness, wolves[i].copy()
            elif fitness < beta_score:
                delta_score, delta = beta_score, beta
                beta_score, beta = fitness, wolves[i].copy()
            elif fitness < delta_score:
                delta_score, delta = fitness, wolves[i].copy()

        # Step 3: Update control parameter 'a'
        a = 2 - 2 * (t / max_iter)

        # Step 4: Update position of wolves
        for i in range(n_agents):
            for j in range(dim):
                r1, r2 = np.random.rand(), np.random.rand()
                A1, C1 = 2 * a * r1 - a, 2 * r2
                D_alpha = abs(C1 * alpha[j] - wolves[i][j])
                X1 = alpha[j] - A1 * D_alpha

                r1, r2 = np.random.rand(), np.random.rand()
                A2, C2 = 2 * a * r1 - a, 2 * r2
                D_beta = abs(C2 * beta[j] - wolves[i][j])
                X2 = beta[j] - A2 * D_beta

                r1, r2 = np.random.rand(), np.random.rand()
                A3, C3 = 2 * a * r1 - a, 2 * r2
                D_delta = abs(C3 * delta[j] - wolves[i][j])
                X3 = delta[j] - A3 * D_delta

                wolves[i][j] = np.clip((X1 + X2 + X3) / 3, lb, ub)

    return alpha, alpha_score

def is_collision(point, grid_size, obstacles):
    x, y = point.astype(int)
    if x < 0 or y < 0 or x >= grid_size[0] or y >= grid_size[1]:
        return True
    for ox1, oy1, ox2, oy2 in obstacles:
        if ox1 <= x <= ox2 and oy1 <= y <= oy2:
            return True
    return False


def make_path_cost(start, goal, grid_size, obstacles):
    def path_cost(waypoints):
        waypoints = waypoints.reshape(-1, 2)
        path = [start] + [w.astype(int) for w in waypoints] + [goal]

        total_dist, penalty = 0, 0
        for i in range(len(path) - 1):
            dist = np.linalg.norm(path[i + 1] - path[i])
            total_dist += dist
            if is_collision(path[i + 1], grid_size, obstacles):
                penalty += 100  # Heavy penalty for hitting obstacle

        # Energy = number of turns (smoothness)
        energy = 0
        for i in range(1, len(path) - 1):
            v1 = path[i] - path[i - 1]
            v2 = path[i + 1] - path[i]
            if np.linalg.norm(v1) > 0 and np.linalg.norm(v2) > 0:
                cos_angle = np.dot(v1, v2) / (np.linalg.norm(v1) * np.linalg.norm(v2))
                angle = np.arccos(np.clip(cos_angle, -1, 1))
                energy += angle

        return total_dist + energy * 5 + penalty

    return path_cost


print("=== Grey Wolf Optimizer (Path Planning) ===")

grid_size = tuple(map(int, input("Enter grid size (e.g., 20 20): ").split()))
start = np.array(list(map(int, input("Enter start point (x y): ").split())))
goal = np.array(list(map(int, input("Enter goal point (x y): ").split())))

n_waypoints = int(input("Enter number of waypoints: "))
n_agents = int(input("Enter number of wolves (agents): "))
max_iter = int(input("Enter maximum iterations: "))


obstacles = []
n_obs = int(input("Enter number of rectangular obstacles: "))
print("Enter obstacle coordinates as: x1 y1 x2 y2")

for i in range(n_obs):
    ox1, oy1, ox2, oy2 = map(int, input(f"Obstacle {i+1}: ").split())
    obstacles.append((ox1, oy1, ox2, oy2))


dim = n_waypoints * 2
path_cost = make_path_cost(start, goal, grid_size, obstacles)

best_path, best_score = gwo(path_cost, dim, (0, grid_size[0]-1), n_agents, max_iter)

best_waypoints = best_path.reshape(-1, 2).astype(int)
final_path = np.vstack([start, best_waypoints, goal])

# Clean path
clean_path = []
for p in final_path:
    pt = tuple(map(int, p))
    if len(clean_path) == 0 or pt != clean_path[-1]:
        clean_path.append(pt)

print("\n=== Best Path Found ===")
for p in clean_path:
    print(p)
print("\nPath Cost:", round(best_score, 2))

OUTPUT:
=== Grey Wolf Optimizer (Path Planning) ===
Enter grid size (e.g., 20 20): 20 20
Enter start point (x y): 0 0
Enter goal point (x y): 19 19
Enter number of waypoints: 5
Enter number of wolves (agents): 30
Enter maximum iterations: 200
Enter number of rectangular obstacles: 3
Enter obstacle coordinates as: x1 y1 x2 y2
Obstacle 1: 5 5 10 10
Obstacle 2: 12 0 14 14
Obstacle 3: 3 15 15 17

=== Best Path Found ===
(0, 0)
(0, 4)
(3, 6)
(17, 16)
(19, 19)

Path Cost: 28.58

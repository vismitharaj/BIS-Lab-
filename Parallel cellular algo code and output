import numpy as np
import random

# --- Step 1: User Inputs ---
num_customers = int(input("Enter number of customers (excluding depot): "))
num_vehicles = int(input("Enter number of vehicles: "))

print("\nEnter the distance matrix (including depot 0):")
print(f"Matrix should be {num_customers + 1} x {num_customers + 1}")
distance_matrix = []

for i in range(num_customers + 1):
    row = list(map(int, input(f"Row {i+1}: ").split()))
    distance_matrix.append(row)

distance_matrix = np.array(distance_matrix)

# Grid and generations
rows = int(input("\nEnter number of grid rows: "))
cols = int(input("Enter number of grid columns: "))
grid_dim = (rows, cols)
population_size = rows * cols

num_generations = int(input("\nEnter number of generations: "))

# --- Step 2: Generate Initial Population ---
def generate_individual():
    perm = list(range(1, num_customers + 1))
    random.shuffle(perm)
    return perm

population = [generate_individual() for _ in range(population_size)]

# --- Step 3: Fitness Function ---
def fitness(individual):
    split_points = np.linspace(0, num_customers, num_vehicles + 1, dtype=int)
    total_distance = 0
    for i in range(num_vehicles):
        route = [0] + individual[split_points[i]:split_points[i+1]] + [0]
        for j in range(len(route) - 1):
            total_distance += distance_matrix[route[j], route[j+1]]
    return total_distance

# --- Step 4: Neighborhood Function ---
def get_neighbors(idx):
    r, c = divmod(idx, grid_dim[1])
    neighbors = []
    for dr in [-1, 0, 1]:
        for dc in [-1, 0, 1]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < grid_dim[0] and 0 <= nc < grid_dim[1]:
                n_idx = nr * grid_dim[1] + nc
                if n_idx != idx:
                    neighbors.append(n_idx)
    return neighbors

# --- Step 5: Genetic Operators ---
def crossover(parent1, parent2):
    size = len(parent1)
    a, b = sorted(random.sample(range(size), 2))
    child = [None] * size
    child[a:b] = parent1[a:b]
    
    pointer = b
    for gene in parent2[b:] + parent2[:b]:
        if gene not in child:
            if pointer == size:
                pointer = 0
            child[pointer] = gene
            pointer += 1
    return child

def mutate(individual):
    a, b = random.sample(range(len(individual)), 2)
    individual[a], individual[b] = individual[b], individual[a]
    return individual

# --- Step 6: PCA Iteration ---
def pca_iteration(pop):
    new_pop = pop.copy()
    for idx in range(len(pop)):
        neighbors = get_neighbors(idx)
        partner_idx = random.choice(neighbors)
        parent1 = pop[idx]
        parent2 = pop[partner_idx]
        
        child = crossover(parent1, parent2)
        if random.random() < 0.2:
            child = mutate(child)
        
        if fitness(child) < fitness(pop[idx]):
            new_pop[idx] = child
    return new_pop

# --- Step 7: Main Loop ---
for gen in range(num_generations):
    population = pca_iteration(population)
    best_fitness = min(fitness(ind) for ind in population)
    print(f"Generation {gen+1}: Best total distance = {best_fitness}")

# --- Step 8: Output ---
best_individual = min(population, key=fitness)
print("\nBest route assignment (split evenly):")
split_points = np.linspace(0, num_customers, num_vehicles + 1, dtype=int)
for i in range(num_vehicles):
    route = [0] + best_individual[split_points[i]:split_points[i+1]] + [0]
    print(f"Vehicle {i+1} route: {route}")
print(f"Total distance: {fitness(best_individual)}")

OUTPUT:
Enter number of customers (excluding depot): 3
Enter number of vehicles: 2

Enter the distance matrix (including depot 0):
Matrix should be 4 x 4
Row 1: 0 2 9 10
Row 2: 2 0 6 4
Row 3: 9 6 0 8
Row 4: 10 4 8 0

Enter number of grid rows: 3
Enter number of grid columns: 3

Enter number of generations: 25
Generation 1: Best total distance = 31
Generation 2: Best total distance = 31
Generation 3: Best total distance = 31
Generation 4: Best total distance = 31
Generation 5: Best total distance = 31
Generation 6: Best total distance = 31
Generation 7: Best total distance = 31
Generation 8: Best total distance = 31
Generation 9: Best total distance = 31
Generation 10: Best total distance = 31
Generation 11: Best total distance = 31
Generation 12: Best total distance = 31
Generation 13: Best total distance = 31
Generation 14: Best total distance = 31
Generation 15: Best total distance = 31
Generation 16: Best total distance = 31
Generation 17: Best total distance = 31
Generation 18: Best total distance = 31
Generation 19: Best total distance = 31
Generation 20: Best total distance = 31
Generation 21: Best total distance = 31
Generation 22: Best total distance = 31
Generation 23: Best total distance = 31
Generation 24: Best total distance = 31
Generation 25: Best total distance = 31

Best route assignment (split evenly):
Vehicle 1 route: [0, 1, 0]
Vehicle 2 route: [0, 3, 2, 0]
Total distance: 31
